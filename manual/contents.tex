\section{Contents of the package}

The LOIS package included contains the following:

\begin{itemize}
\item source code (LOIS library itself, and the sample programs described above).
\item a Makefile which includes the {\tt all} target
which compiles the LOIS library and the
two programs, runs the two programs, and saves the output.
\item The result of
{\tt make all} (both binaries and their output), obtained on the first system.
\end{itemize}

%LOIS has been tested on machines with the following configurations:

%\begin{itemize}
%\item gcc version 4.4.3, architecture i686, Ubuntu Linux

%\item gcc version 4.6.3, architecture x86\_64, Ubuntu Linux
%\end{itemize}

%Note that, while all the core functionality of LOIS works, some simple useful operators
%and functions (in particular, those working on \verb|relem| as opposed to the simple
%\verb|elem|) might not be yet implemented, or might require some obvious type casting
%(a function variant for specific types might be missing, making C++ unable to guess
%what typecasts should be used).

\subsection{Sample programs}\label{app:samples}
The subdirectory \verb-tests- includes some sample programs. 

\subsubsection{Tutorial}

The program \verb-tests/tutorial.cpp- includes the tutorial given in 
Section \ref{sec_tut}, as well as some other code snippets quoted in this paper.
These snippets, as well as their outputs, are inserted
directly from \verb-tests/tutorial.cpp- or its output.
                                       
\subsubsection{Automatic tests}

The program \verb-tests/autotest.cpp- performs some automatic testing of LOIS.
This includes some interesting applications of LOIS, allowing
one to see that LOIS runs correctly, and how fast does it run.
The following tests are conducted:

\begin{itemize}
\item \verb-testRandomBipartite-

Let $R$ be a random symmetric
and anti-reflexive relation, and let $A_1$ and $A_2$ be a random 2-partition. Let
$S(x,y)$ iff $x$ and $y$ are in different parts of the partition.
We construct a new relation $E = R \cap S$. In graph theoretic terms,
$R$ is Rado's random graph, $S$ is a complete bipartite graph, and $E$ is a random
bipartite graph. We take one vertex $x \in \bbA$ and run BFS on the graph, and ask
about the number of iterations after which we have reached every vertex. The program
correctly answers that every vertex is reached after 3 iterations.

This test evaluates in roughly 3 milliseconds on the machine used for tests.

\item \verb-testTree-

A function is given elements
$x_1, \ldots, x_k$ of the homogeneous tree, and asks questions about relationships
between them. Once the answers uniquely determine the substructure generated by
$x_1, \ldots, x_k$, the substructure is presented in a readable form. For four elements
without any relations, 416 possible structures are generated (262 if we know that all
the four elements are not equal --- see sequences A005264 and A005172 in \cite{oeis}).

This test evaluates in roughly four seconds on our machine (for four elements).
This time is relatively long because of two reasons:

\begin{itemize}
\item 
The extension bound of the homogeneous
tree is relatively large ($e(n)=8n-4$, which gives the evaluation time of
roughly $8^k k!$ according to Proposition 1 in %\ref{prop:solver} in
\cite{lois-sat}). In fact 
Proposition 1 is not optimal, all trees are generated in time
roughly linear in the number of all trees, which is 416 for four elements. Still,
it grows quite fast.

\item The
program is very ineffective: currently, each question tries to generate all the possible
structures from the beginning, even if we know that some possible structures have been
already ruled out.
\end{itemize}

Therefore, the running time is actually at least quadratic in the
number of possible trees. This should be optimized in the future versions of LOIS.

\item \verb-testOrder-

This test the basic properties of the order relation, and evaluates very quickly.

\item \verb-testAssigment-

This checks whether an assignment exception is correctly thrown 
when we try to assign a value
(\verb-rbool-, in this case) which uses variables which are not in the internal
context of the variable we are assigning to.

\item \verb-testQueue-

This checks whether the \verb-setof-'s and the queue semantics of the \verb-for-
loop works correctly. Numbers from 0 to 10 are inserted to \verb-lsetof<int>-.

\item \verb-testRemoval-

This checks whether the \verb|-=| operator works in the natural, pseudo-parallel
way, as advertised in paper.
\end{itemize}

\subsubsection{Minimisation of an automaton}

The program \verb-tests/mintest.cpp- tries to perform the minimisation algorithm
on an orbit finite automaton. This automaton over the alphabet $\bbA$ (our infinite
domain) reads
three symbols, and accepts iff either two of them are equal (if there are less than
three or more than three symbols, the word is rejected). The minimisation algorithm
works in a way similar to the usual one for finite automata. The equivalence relation $\eta \subseteq Q \times Q$ is computed --
two states will be in $\eta$ if they can be merged into a single state. Initially,
$\eta$ is set to $F \times F \cup (Q-F) \times (Q-F)$, and then, in each iteration
states each $x,y \in Q$ are separated iff $\neg \eta(\delta(x,a), \delta(y,a))$ for some
symbol $a$ in the alphabet. For this particular automaton minimisation takes four
iterations. The algorithm is implemented using two representations ($\eta$ is
represented either as a relation or as the set of equivalence classes), and currently
takes 0.15 s in the relation representation, and 32 s in the equivalence class representation.

\subsubsection{Solver tests}\label{app:sol_tests}
The program \verb-tests/soltest.cpp- tests various solvers on several LOIS functions.
The table in \cite{lois-sat} is based on its results. The following tests
are included:

\begin{itemize}
\item \verb-testOrder- 
This test the basic properties of the order relation, and evaluates very quickly
with the internal solver, although external solvers have problems with it.

\item \verb-testReachable- 
Reachability from the article (Section \ref{sec_tut}).

\item \verb-testReal- 
This test the basic properties of the \verb-Real- sort (LRA logic).

\item \verb-testMinimize??-
These tests minimize automata. There are two automata: A (the same as in
\verb-tests/mintest.cpp-) and B (the automaton using the integers from the
introduction), and three different implementations of the minimisation algorithm
(two from \verb-tests/mintest.cpp-, and the one shown in the Introduction is
implementation number 3). Internal solver and SPASS work on the automaton A, but none of the solvers work on B.

\item \verb-testPacking-
What are the maximal sets of subsets of (0,5) such that no two points are in distance
less than 1? Z3 correctly calculates using the LRA logic that such maximal sets can
have from 3 to 5 elements.

\item \verb-testCirclePacking-
This tests the NRA logic by asking about packings of disks in a larger disk. 
None of the tested solvers can answer even the simplest questions here.
\end{itemize}

The external solvers where called using the following commands:


  \begin{description}\footnotesize
  \def\solver#1#2{\item [\bf #1:] {\tt #2}}
  \solver{Z3}{z3-*/bin/z3 -smt2 -in -t:500}
  \solver{CVC4}{cvc4 --lang smt --incremental --tlimit-per=500}
  \solver{CVC4*}{{cvc4 --lang smt --incremental --finite-model-find --tlimit-per=500}}
  \solver{SPASS}{SPASS -TimeLimit=1}
  \end{description}

\subsubsection{Learning automata}

The paper \cite{learningnominal} extends the famous Angluin algorithm of learning
of deterministic finite automata, as well as Bollig et al's version for non-deterministic
finite automata, to definable automata. The sample program {\tt tests/learning.cpp}
implements the algorithm given in \cite{learningnominal}, as well as includes tests
based on the paper. Multiple algorithms and tests can be activated by enabling and
disabling the conditional definitions at the head of the source code.

\subsubsection{Reducing definable CSPs to finite ones}

The paper \cite{infcsp} shows a reduction from definable CSPs over a finite template
to finite CSPs. This reduction is implemented by the program {\tt tests/csp.cpp}.
